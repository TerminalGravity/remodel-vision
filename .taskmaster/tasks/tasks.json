{
  "meta": {
    "projectName": "RemodelVision",
    "version": "1.0.0",
    "generatedAt": "2025-12-08",
    "totalTasks": 50,
    "completedTasks": 0
  },
  "tasks": [
    {
      "id": "1",
      "title": "Implement Firecrawl property data fetching service",
      "description": "Create a service that fetches property data from Zillow, Redfin, and county assessor sites using Firecrawl API. Should return structured PropertyContext data with confidence scores.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "prdReference": "PRD-001, PRD-005",
      "subtasks": [
        {
          "id": "1.1",
          "title": "Set up Firecrawl API client and configuration",
          "status": "pending"
        },
        {
          "id": "1.2",
          "title": "Implement Zillow scraping with extraction schema",
          "status": "pending"
        },
        {
          "id": "1.3",
          "title": "Implement Redfin scraping with extraction schema",
          "status": "pending"
        },
        {
          "id": "1.4",
          "title": "Implement county assessor scraping",
          "status": "pending"
        },
        {
          "id": "1.5",
          "title": "Create data merging logic with confidence scoring",
          "status": "pending"
        }
      ],
      "estimatedTokens": 15000
    },
    {
      "id": "2",
      "title": "Create PropertyContext TypeScript schema with Zod validation",
      "description": "Implement the complete PropertyContext type system as defined in PRD-008, including all nested types and Zod validation schemas.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "prdReference": "PRD-008",
      "subtasks": [
        {
          "id": "2.1",
          "title": "Define PropertyContext interface in types/property.ts",
          "status": "pending"
        },
        {
          "id": "2.2",
          "title": "Define RoomContext interface in types/room.ts",
          "status": "pending"
        },
        {
          "id": "2.3",
          "title": "Define MeasurementSet interface in types/measurements.ts",
          "status": "pending"
        },
        {
          "id": "2.4",
          "title": "Create Zod validation schemas for all types",
          "status": "pending"
        },
        {
          "id": "2.5",
          "title": "Add utility functions for type conversions",
          "status": "pending"
        }
      ],
      "estimatedTokens": 12000
    },
    {
      "id": "3",
      "title": "Build document upload and processing pipeline",
      "description": "Create a complete document processing pipeline that handles uploads, classifies document types, and extracts data using Gemini Vision.",
      "status": "pending",
      "priority": "high",
      "dependencies": [
        "2"
      ],
      "prdReference": "PRD-005",
      "subtasks": [
        {
          "id": "3.1",
          "title": "Create document upload UI component with drag-and-drop",
          "status": "pending"
        },
        {
          "id": "3.2",
          "title": "Implement document type detection using Gemini Vision",
          "status": "pending"
        },
        {
          "id": "3.3",
          "title": "Create floor plan extraction agent",
          "status": "pending"
        },
        {
          "id": "3.4",
          "title": "Create room photo analysis agent",
          "status": "pending"
        },
        {
          "id": "3.5",
          "title": "Build extraction review UI for user verification",
          "status": "pending"
        }
      ],
      "estimatedTokens": 20000
    },
    {
      "id": "4",
      "title": "Extend Gemini service with full model family support",
      "description": "Expand the existing geminiService.ts to support all Gemini-3 models including streaming, workflow orchestration, and cost tracking.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "prdReference": "PRD-003",
      "subtasks": [
        {
          "id": "4.1",
          "title": "Add model configuration for gemini-2.5-pro and video models",
          "status": "pending"
        },
        {
          "id": "4.2",
          "title": "Implement streaming response handler for chat",
          "status": "pending"
        },
        {
          "id": "4.3",
          "title": "Create workflow engine for multi-step AI operations",
          "status": "pending"
        },
        {
          "id": "4.4",
          "title": "Add token usage tracking and cost estimation",
          "status": "pending"
        },
        {
          "id": "4.5",
          "title": "Implement error handling with retry logic",
          "status": "pending"
        }
      ],
      "estimatedTokens": 18000
    },
    {
      "id": "5",
      "title": "Implement context injection system for AI prompts",
      "description": "Create a context injection system that automatically includes relevant PropertyContext, RoomContext, and design history in all AI prompts.",
      "status": "pending",
      "priority": "high",
      "dependencies": [
        "2",
        "4"
      ],
      "prdReference": "PRD-003",
      "subtasks": [
        {
          "id": "5.1",
          "title": "Create ContextInjectionConfig interface and builder",
          "status": "pending"
        },
        {
          "id": "5.2",
          "title": "Implement property context formatter",
          "status": "pending"
        },
        {
          "id": "5.3",
          "title": "Implement room context formatter",
          "status": "pending"
        },
        {
          "id": "5.4",
          "title": "Add context toggle UI in sidebar",
          "status": "pending"
        },
        {
          "id": "5.5",
          "title": "Implement token limit truncation",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "6",
      "title": "Create PropertyContext-driven 3D geometry generator",
      "description": "Replace placeholder room geometry with actual geometry generated from PropertyContext measurements using Three.js.",
      "status": "pending",
      "priority": "high",
      "dependencies": [
        "2"
      ],
      "prdReference": "PRD-002",
      "subtasks": [
        {
          "id": "6.1",
          "title": "Create geometryGenerator service",
          "status": "pending"
        },
        {
          "id": "6.2",
          "title": "Implement wall generation with openings",
          "status": "pending"
        },
        {
          "id": "6.3",
          "title": "Implement floor and ceiling generation",
          "status": "pending"
        },
        {
          "id": "6.4",
          "title": "Add feature meshes (windows, doors, built-ins)",
          "status": "pending"
        },
        {
          "id": "6.5",
          "title": "Create accuracy indicator overlay",
          "status": "pending"
        }
      ],
      "estimatedTokens": 15000
    },
    {
      "id": "7",
      "title": "Implement multi-room navigation system",
      "description": "Add smooth camera transitions between rooms with a room selector UI and keyboard navigation support.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "6"
      ],
      "prdReference": "PRD-002",
      "subtasks": [
        {
          "id": "7.1",
          "title": "Create useCameraNavigation hook",
          "status": "pending"
        },
        {
          "id": "7.2",
          "title": "Implement smooth camera transitions with GSAP",
          "status": "pending"
        },
        {
          "id": "7.3",
          "title": "Add room selector dropdown component",
          "status": "pending"
        },
        {
          "id": "7.4",
          "title": "Add view mode selector (dollhouse, floor plan, room focus)",
          "status": "pending"
        },
        {
          "id": "7.5",
          "title": "Implement keyboard navigation (arrow keys)",
          "status": "pending"
        }
      ],
      "estimatedTokens": 12000
    },
    {
      "id": "8",
      "title": "Build measurement visualization layer",
      "description": "Display room dimensions, heights, and clearances as overlays on the 3D view with toggle controls.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "6"
      ],
      "prdReference": "PRD-002",
      "subtasks": [
        {
          "id": "8.1",
          "title": "Create MeasurementLayer component",
          "status": "pending"
        },
        {
          "id": "8.2",
          "title": "Implement MeasurementLine with labels",
          "status": "pending"
        },
        {
          "id": "8.3",
          "title": "Add dimension callouts for walls",
          "status": "pending"
        },
        {
          "id": "8.4",
          "title": "Add clearance indicators",
          "status": "pending"
        },
        {
          "id": "8.5",
          "title": "Create measurement toggle UI",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "9",
      "title": "Enhance image generation pipeline with perspective matching",
      "description": "Improve the generateRemodel function to include camera metadata and ensure perspective accuracy in generated images.",
      "status": "pending",
      "priority": "high",
      "dependencies": [
        "4",
        "5"
      ],
      "prdReference": "PRD-004",
      "subtasks": [
        {
          "id": "9.1",
          "title": "Create ViewportCapture interface with camera metadata",
          "status": "pending"
        },
        {
          "id": "9.2",
          "title": "Implement perspective prompt builder",
          "status": "pending"
        },
        {
          "id": "9.3",
          "title": "Add room dimensions to generation context",
          "status": "pending"
        },
        {
          "id": "9.4",
          "title": "Implement output validation using Gemini Vision",
          "status": "pending"
        },
        {
          "id": "9.5",
          "title": "Add quality enhancement prompts",
          "status": "pending"
        }
      ],
      "estimatedTokens": 14000
    },
    {
      "id": "10",
      "title": "Implement style-material mapping system",
      "description": "Create a configuration system that maps design styles to appropriate materials, colors, and textures for each budget tier.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "2"
      ],
      "prdReference": "PRD-004",
      "subtasks": [
        {
          "id": "10.1",
          "title": "Create StyleMaterialPalette interface",
          "status": "pending"
        },
        {
          "id": "10.2",
          "title": "Define palettes for Modern, Farmhouse, Coastal styles",
          "status": "pending"
        },
        {
          "id": "10.3",
          "title": "Define palettes for Transitional, Scandinavian, Industrial",
          "status": "pending"
        },
        {
          "id": "10.4",
          "title": "Create getMaterialsForBudget utility",
          "status": "pending"
        },
        {
          "id": "10.5",
          "title": "Integrate with image generation prompt builder",
          "status": "pending"
        }
      ],
      "estimatedTokens": 8000
    },
    {
      "id": "11",
      "title": "Build Discover Inspiration content generator",
      "description": "Create the AI-powered inspiration engine that generates personalized style guides, mood boards, and product suggestions.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "4",
        "5",
        "10"
      ],
      "prdReference": "PRD-003, PRD-004",
      "subtasks": [
        {
          "id": "11.1",
          "title": "Create InspirationRequest and InspirationResult interfaces",
          "status": "pending"
        },
        {
          "id": "11.2",
          "title": "Implement generateStyleGuide function",
          "status": "pending"
        },
        {
          "id": "11.3",
          "title": "Implement generateMoodBoard function",
          "status": "pending"
        },
        {
          "id": "11.4",
          "title": "Implement generateProductSuggestions function",
          "status": "pending"
        },
        {
          "id": "11.5",
          "title": "Build Discover Inspiration UI panel",
          "status": "pending"
        }
      ],
      "estimatedTokens": 16000
    },
    {
      "id": "12",
      "title": "Implement design version history system",
      "description": "Create a complete version history system for designs with comparison, favorites, and rating functionality.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "2",
        "9"
      ],
      "prdReference": "PRD-004, PRD-008",
      "subtasks": [
        {
          "id": "12.1",
          "title": "Create DesignVersion interface and store",
          "status": "pending"
        },
        {
          "id": "12.2",
          "title": "Implement version saving on generation",
          "status": "pending"
        },
        {
          "id": "12.3",
          "title": "Build version history panel UI",
          "status": "pending"
        },
        {
          "id": "12.4",
          "title": "Add version comparison slider",
          "status": "pending"
        },
        {
          "id": "12.5",
          "title": "Implement favorites and rating system",
          "status": "pending"
        }
      ],
      "estimatedTokens": 12000
    },
    {
      "id": "13",
      "title": "Create schematic overlay system for contractor views",
      "description": "Implement toggleable schematic overlays for electrical, plumbing, HVAC, and demolition plans on the 3D view.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "6",
        "8"
      ],
      "prdReference": "PRD-002, PRD-007",
      "subtasks": [
        {
          "id": "13.1",
          "title": "Create SchematicOverlay component architecture",
          "status": "pending"
        },
        {
          "id": "13.2",
          "title": "Implement electrical overlay with symbols",
          "status": "pending"
        },
        {
          "id": "13.3",
          "title": "Implement plumbing overlay with pipe routes",
          "status": "pending"
        },
        {
          "id": "13.4",
          "title": "Add layer toggle UI",
          "status": "pending"
        },
        {
          "id": "13.5",
          "title": "Create schematic legend component",
          "status": "pending"
        }
      ],
      "estimatedTokens": 14000
    },
    {
      "id": "14",
      "title": "Enhance before/after comparison with annotations",
      "description": "Extend the ResultOverlay component with auto-generated annotations highlighting design changes.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "9"
      ],
      "prdReference": "PRD-004",
      "subtasks": [
        {
          "id": "14.1",
          "title": "Implement generateComparisonAnnotations function",
          "status": "pending"
        },
        {
          "id": "14.2",
          "title": "Create AnnotationMarker component",
          "status": "pending"
        },
        {
          "id": "14.3",
          "title": "Add annotation toggle in comparison view",
          "status": "pending"
        },
        {
          "id": "14.4",
          "title": "Implement changes summary generation",
          "status": "pending"
        },
        {
          "id": "14.5",
          "title": "Add export comparison as single image",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "15",
      "title": "Build data merge and conflict resolution system",
      "description": "Create the intelligent data merging system that combines data from multiple sources with conflict detection and resolution UI.",
      "status": "pending",
      "priority": "high",
      "dependencies": [
        "1",
        "2",
        "3"
      ],
      "prdReference": "PRD-005",
      "subtasks": [
        {
          "id": "15.1",
          "title": "Create mergePropertyData function with priority logic",
          "status": "pending"
        },
        {
          "id": "15.2",
          "title": "Implement conflict detection algorithm",
          "status": "pending"
        },
        {
          "id": "15.3",
          "title": "Build conflict resolution UI",
          "status": "pending"
        },
        {
          "id": "15.4",
          "title": "Add source attribution tracking",
          "status": "pending"
        },
        {
          "id": "15.5",
          "title": "Implement merge history logging",
          "status": "pending"
        }
      ],
      "estimatedTokens": 12000
    },
    {
      "id": "16",
      "title": "Implement product reference and specification system",
      "description": "Create the system for linking designs to specific products with SKUs, pricing, and vendor information.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "2"
      ],
      "prdReference": "PRD-004, PRD-008",
      "subtasks": [
        {
          "id": "16.1",
          "title": "Create ProductReference interface and store",
          "status": "pending"
        },
        {
          "id": "16.2",
          "title": "Build product picker component",
          "status": "pending"
        },
        {
          "id": "16.3",
          "title": "Implement product search via Gemini",
          "status": "pending"
        },
        {
          "id": "16.4",
          "title": "Add product placement to generation context",
          "status": "pending"
        },
        {
          "id": "16.5",
          "title": "Create specification sheet export",
          "status": "pending"
        }
      ],
      "estimatedTokens": 14000
    },
    {
      "id": "17",
      "title": "Build generation queue and job management",
      "description": "Implement a queue system for managing multiple AI generation requests with progress tracking and retry logic.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "9"
      ],
      "prdReference": "PRD-004",
      "subtasks": [
        {
          "id": "17.1",
          "title": "Create GenerationQueue class",
          "status": "pending"
        },
        {
          "id": "17.2",
          "title": "Implement job status tracking",
          "status": "pending"
        },
        {
          "id": "17.3",
          "title": "Add automatic retry logic",
          "status": "pending"
        },
        {
          "id": "17.4",
          "title": "Build queue status UI",
          "status": "pending"
        },
        {
          "id": "17.5",
          "title": "Implement concurrent job limiting",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "18",
      "title": "Create PropertyIntelligence enhanced panel",
      "description": "Extend the existing PropertyIntelligence component with completeness tracking, missing data prompts, and manual override capabilities.",
      "status": "pending",
      "priority": "high",
      "dependencies": [
        "1",
        "2"
      ],
      "prdReference": "PRD-001",
      "subtasks": [
        {
          "id": "18.1",
          "title": "Add completeness percentage calculation",
          "status": "pending"
        },
        {
          "id": "18.2",
          "title": "Create missing data prompt UI",
          "status": "pending"
        },
        {
          "id": "18.3",
          "title": "Implement manual field override",
          "status": "pending"
        },
        {
          "id": "18.4",
          "title": "Add data source indicators",
          "status": "pending"
        },
        {
          "id": "18.5",
          "title": "Integrate with document upload flow",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "19",
      "title": "Implement multi-project dashboard enhancements",
      "description": "Enhance the Dashboard component with instant context switching, portfolio summary, and project status tracking.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "2"
      ],
      "prdReference": "PERSONA-002",
      "subtasks": [
        {
          "id": "19.1",
          "title": "Add portfolio summary widget",
          "status": "pending"
        },
        {
          "id": "19.2",
          "title": "Implement quick context switch (<500ms)",
          "status": "pending"
        },
        {
          "id": "19.3",
          "title": "Add needs attention section",
          "status": "pending"
        },
        {
          "id": "19.4",
          "title": "Implement search and filter",
          "status": "pending"
        },
        {
          "id": "19.5",
          "title": "Add project status badges",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "20",
      "title": "Create contractor export package generator",
      "description": "Build the functionality to generate professional PDF packages with specs, dimensions, and product lists for contractor handoff.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "8",
        "13",
        "16"
      ],
      "prdReference": "PERSONA-003, PRD-007",
      "subtasks": [
        {
          "id": "20.1",
          "title": "Create PDF generation service",
          "status": "pending"
        },
        {
          "id": "20.2",
          "title": "Build specification template",
          "status": "pending"
        },
        {
          "id": "20.3",
          "title": "Add schematic overlay rendering to PDF",
          "status": "pending"
        },
        {
          "id": "20.4",
          "title": "Create material/product schedule",
          "status": "pending"
        },
        {
          "id": "20.5",
          "title": "Add export UI with options",
          "status": "pending"
        }
      ],
      "estimatedTokens": 14000
    },
    {
      "id": "21",
      "title": "Implement Zustand store persistence with migrations",
      "description": "Add IndexedDB persistence to the Zustand store with proper schema versioning and migration support.",
      "status": "pending",
      "priority": "high",
      "dependencies": [
        "2"
      ],
      "prdReference": "PRD-008",
      "subtasks": [
        {
          "id": "21.1",
          "title": "Configure zustand-persist middleware",
          "status": "pending"
        },
        {
          "id": "21.2",
          "title": "Implement partialize function for selective persistence",
          "status": "pending"
        },
        {
          "id": "21.3",
          "title": "Create migration functions for schema changes",
          "status": "pending"
        },
        {
          "id": "21.4",
          "title": "Add storage quota management",
          "status": "pending"
        },
        {
          "id": "21.5",
          "title": "Implement export/import functionality",
          "status": "pending"
        }
      ],
      "estimatedTokens": 8000
    },
    {
      "id": "22",
      "title": "Add FIRECRAWL_API_KEY environment variable and setup",
      "description": "Configure the Firecrawl API key in the environment and update Vite config to expose it.",
      "status": "pending",
      "priority": "high",
      "dependencies": [],
      "prdReference": "PRD-005",
      "subtasks": [
        {
          "id": "22.1",
          "title": "Add FIRECRAWL_API_KEY to env.example",
          "status": "pending"
        },
        {
          "id": "22.2",
          "title": "Update vite.config.ts to expose the key",
          "status": "pending"
        },
        {
          "id": "22.3",
          "title": "Add @mendable/firecrawl-js to package.json",
          "status": "pending"
        },
        {
          "id": "22.4",
          "title": "Create Firecrawl client initialization",
          "status": "pending"
        }
      ],
      "estimatedTokens": 2000
    },
    {
      "id": "23",
      "title": "Implement floor plan extraction from images",
      "description": "Create the AI workflow that extracts room layouts, dimensions, and features from uploaded floor plan images.",
      "status": "pending",
      "priority": "high",
      "dependencies": [
        "3",
        "4"
      ],
      "prdReference": "PRD-005",
      "subtasks": [
        {
          "id": "23.1",
          "title": "Create floor plan detection prompt",
          "status": "pending"
        },
        {
          "id": "23.2",
          "title": "Implement room boundary extraction",
          "status": "pending"
        },
        {
          "id": "23.3",
          "title": "Extract labeled dimensions",
          "status": "pending"
        },
        {
          "id": "23.4",
          "title": "Identify doors and windows",
          "status": "pending"
        },
        {
          "id": "23.5",
          "title": "Map to RoomContext schema",
          "status": "pending"
        }
      ],
      "estimatedTokens": 12000
    },
    {
      "id": "24",
      "title": "Create room photo analysis workflow",
      "description": "Build the AI workflow that analyzes room photos to extract current state, features, and condition assessment.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "3",
        "4"
      ],
      "prdReference": "PRD-005",
      "subtasks": [
        {
          "id": "24.1",
          "title": "Create room type classification prompt",
          "status": "pending"
        },
        {
          "id": "24.2",
          "title": "Implement condition assessment extraction",
          "status": "pending"
        },
        {
          "id": "24.3",
          "title": "Extract flooring, walls, ceiling details",
          "status": "pending"
        },
        {
          "id": "24.4",
          "title": "Identify fixtures and features",
          "status": "pending"
        },
        {
          "id": "24.5",
          "title": "Estimate dimensions from photo",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "25",
      "title": "Build style quiz onboarding flow",
      "description": "Create an interactive style quiz that captures user preferences and generates initial design DNA for the project.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "2"
      ],
      "prdReference": "PERSONA-001",
      "subtasks": [
        {
          "id": "25.1",
          "title": "Design quiz question flow",
          "status": "pending"
        },
        {
          "id": "25.2",
          "title": "Create style selection UI with images",
          "status": "pending"
        },
        {
          "id": "25.3",
          "title": "Implement budget tier selection",
          "status": "pending"
        },
        {
          "id": "25.4",
          "title": "Build preference capture (likes/dislikes)",
          "status": "pending"
        },
        {
          "id": "25.5",
          "title": "Generate designDNA from quiz results",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "26",
      "title": "Implement WebGPU feature detection and fallback",
      "description": "Add WebGPU capability detection with graceful fallback to WebGL2/WebGL for older browsers.",
      "status": "pending",
      "priority": "low",
      "dependencies": [],
      "prdReference": "PRD-002",
      "subtasks": [
        {
          "id": "26.1",
          "title": "Create detectCapabilities utility",
          "status": "pending"
        },
        {
          "id": "26.2",
          "title": "Implement WebGPU adapter check",
          "status": "pending"
        },
        {
          "id": "26.3",
          "title": "Add fallback chain (WebGPU → WebGL2 → WebGL)",
          "status": "pending"
        },
        {
          "id": "26.4",
          "title": "Store capability in app context",
          "status": "pending"
        }
      ],
      "estimatedTokens": 4000
    },
    {
      "id": "27",
      "title": "Create annotation system for 3D view",
      "description": "Build a comprehensive annotation system for adding notes, callouts, and warnings to the 3D visualization.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "6"
      ],
      "prdReference": "PRD-002, PRD-007",
      "subtasks": [
        {
          "id": "27.1",
          "title": "Create Annotation interface and store",
          "status": "pending"
        },
        {
          "id": "27.2",
          "title": "Implement annotation placement in 3D space",
          "status": "pending"
        },
        {
          "id": "27.3",
          "title": "Build annotation type icons (warning, info, note)",
          "status": "pending"
        },
        {
          "id": "27.4",
          "title": "Add click-to-add annotation interaction",
          "status": "pending"
        },
        {
          "id": "27.5",
          "title": "Create annotation list panel",
          "status": "pending"
        }
      ],
      "estimatedTokens": 10000
    },
    {
      "id": "28",
      "title": "Implement URL-based property data fetching",
      "description": "Add the ability to paste a property listing URL and automatically extract data using Firecrawl.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "1"
      ],
      "prdReference": "PRD-005",
      "subtasks": [
        {
          "id": "28.1",
          "title": "Create URL input component",
          "status": "pending"
        },
        {
          "id": "28.2",
          "title": "Detect source from URL pattern",
          "status": "pending"
        },
        {
          "id": "28.3",
          "title": "Implement Firecrawl scrapeUrl call",
          "status": "pending"
        },
        {
          "id": "28.4",
          "title": "Parse and structure extracted data",
          "status": "pending"
        },
        {
          "id": "28.5",
          "title": "Show extraction preview before import",
          "status": "pending"
        }
      ],
      "estimatedTokens": 8000
    },
    {
      "id": "29",
      "title": "Build budget tracking and estimation system",
      "description": "Create a system for tracking renovation budgets with AI-powered cost estimation based on scope and location.",
      "status": "pending",
      "priority": "medium",
      "dependencies": [
        "2",
        "4"
      ],
      "prdReference": "PRD-008, PERSONA-002",
      "subtasks": [
        {
          "id": "29.1",
          "title": "Create BudgetBreakdown interface",
          "status": "pending"
        },
        {
          "id": "29.2",
          "title": "Implement cost estimation by category",
          "status": "pending"
        },
        {
          "id": "29.3",
          "title": "Add location-based cost adjustments",
          "status": "pending"
        },
        {
          "id": "29.4",
          "title": "Build budget tracker UI",
          "status": "pending"
        },
        {
          "id": "29.5",
          "title": "Implement budget alerts for overruns",
          "status": "pending"
        }
      ],
      "estimatedTokens": 12000
    },
    {
      "id": "30",
      "title": "Add shareable link generation for designs",
      "description": "Implement the ability to generate shareable links that allow others to view (not edit) a design.",
      "status": "pending",
      "priority": "low",
      "dependencies": [
        "12"
      ],
      "prdReference": "PRD-004",
      "subtasks": [
        {
          "id": "30.1",
          "title": "Create share token generation",
          "status": "pending"
        },
        {
          "id": "30.2",
          "title": "Build read-only viewer route",
          "status": "pending"
        },
        {
          "id": "30.3",
          "title": "Implement share dialog UI",
          "status": "pending"
        },
        {
          "id": "30.4",
          "title": "Add expiration options",
          "status": "pending"
        }
      ],
      "estimatedTokens": 6000
    }
  ],
  "phases": [
    {
      "id": "phase-1",
      "name": "Context Foundation",
      "description": "Build the core data infrastructure and property context system",
      "taskIds": [
        "1",
        "2",
        "3",
        "15",
        "18",
        "21",
        "22"
      ],
      "estimatedWeeks": 3
    },
    {
      "id": "phase-2",
      "name": "AI Generation",
      "description": "Implement full Gemini model family integration and image generation",
      "taskIds": [
        "4",
        "5",
        "9",
        "10",
        "11",
        "17"
      ],
      "estimatedWeeks": 3
    },
    {
      "id": "phase-3",
      "name": "3D Enhancement",
      "description": "Upgrade the 3D dollhouse with property-driven geometry and navigation",
      "taskIds": [
        "6",
        "7",
        "8",
        "26",
        "27"
      ],
      "estimatedWeeks": 3
    },
    {
      "id": "phase-4",
      "name": "Professional Features",
      "description": "Add contractor and designer tools, versioning, and export capabilities",
      "taskIds": [
        "12",
        "13",
        "14",
        "16",
        "19",
        "20",
        "29",
        "30"
      ],
      "estimatedWeeks": 3
    }
  ],
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Monorepo & Tooling Setup for RemodelVision",
        "description": "Set up the base React + TypeScript + Vite monorepo with shared configuration, linting, formatting, and CI ready for core modules.",
        "details": "Implementation details:\n- Initialize a new Git repository and configure a monorepo-friendly structure even if starting with a single app, e.g.:\n  - `/apps/web` – main RemodelVision app\n  - `/packages/ui` – shared UI components (future)\n  - `/packages/core` – shared domain models and utilities (future)\n- Use **Vite 6.2.0** with React and TypeScript template:\n  - `pnpm create vite@latest web --template react-ts` (or npm/yarn equivalent) and then pin Vite to 6.2.0 in `package.json`.\n- Upgrade React and TypeScript to specified versions:\n  - React 19.2.1 (when published) or latest 19.x that matches 19.2.1 API surface; pin in `package.json`.\n  - TypeScript 5.8.2 (or latest 5.8.x) and configure `tsconfig.json` with `strict: true`, `noUncheckedIndexedAccess: true`, `moduleResolution: bundler`.\n- Configure path aliases for domain-centric structure:\n  - `@core/*` → `/packages/core/src/*`\n  - `@ui/*` → `/packages/ui/src/*`\n  - `@app/*` → `/apps/web/src/*`\n- Add linting and formatting:\n  - ESLint with `@typescript-eslint` and React hooks rules.\n  - Prettier with Tailwind plugin for class sorting.\n  - Simple `lint` and `format` scripts in root `package.json`.\n- Add basic CI pipeline (GitHub Actions or similar) to run `pnpm install`, `pnpm lint`, `pnpm test`, `pnpm build` on pull requests.\n- Configure environment variable handling using `.env.local` and `.env.example` with placeholders for API keys (Gemini, Firecrawl, Zillow, etc.).\n\nPseudo-code (folder layout):\n```txt\n/apps\n  /web\n    index.html\n    vite.config.ts\n    src/\n      main.tsx\n      App.tsx\n      shared/\n/packages\n  /core\n    src/index.ts\n  /ui\n    src/index.ts\npnpm-workspace.yaml\n.eslintrc.cjs\n.prettierrc\n```",
        "testStrategy": "- Verify `pnpm install` and `pnpm build` succeed on a clean checkout.\n- Run `pnpm dev` and confirm base React app loads without console errors.\n- Confirm TypeScript strict mode reports no errors in starter files.\n- Validate CI pipeline passes on an initial commit and on a PR with a deliberate lint failure.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [],
        "updatedAt": "2025-12-09T05:42:13.022Z"
      },
      {
        "id": "2",
        "title": "Frontend Styling, Icons, and Layout Baseline",
        "description": "Configure Tailwind CSS via CDN, Lucide React icons, and establish base layout components for the application shell.",
        "details": "Implementation details:\n- Use **Tailwind CSS via CDN** as specified, configured in `index.html` with a minimal `tailwind.config` in a `<script>` block to customize theme tokens where needed (spacing, colors for RemodelVision brand).\n- Define global layout primitives in React:\n  - `<AppShell>` with header (app title, project switcher placeholder), sidebar (navigation for Context, 3D, AI Studio, Projects), and main content area.\n  - Use semantic HTML and CSS Grid/Flexbox combined with Tailwind utility classes.\n- Install **Lucide React 0.556.0**:\n  - `pnpm add lucide-react@0.556.0` in web app.\n  - Create an `Icon.tsx` wrapper if needed for centralized icon sizing/color.\n- Establish responsive breakpoints for tablet/desktop, assuming desktop-first but supporting smaller widths.\n- Set up a minimal design system using Tailwind utility presets, e.g. button variants, cards, panels, tabs using standard class combinations stored as `const` strings or small wrapper components in `/packages/ui`.\n\nPseudo-code:\n```tsx\n// App.tsx\nexport function App() {\n  return (\n    <AppShell>\n      <Sidebar>\n        <NavItem icon={Home}>Dashboard</NavItem>\n        <NavItem icon={Map}>Properties</NavItem>\n        <NavItem icon={Cube}>3D Dollhouse</NavItem>\n        <NavItem icon={Wand2}>AI Studio</NavItem>\n        <NavItem icon={Calendar}>Projects</NavItem>\n      </Sidebar>\n      <MainContent>\n        {/* Route outlet / tab content */}\n      </MainContent>\n    </AppShell>\n  );\n}\n```",
        "testStrategy": "- Manually verify layout in Chrome, Firefox, and Safari at 1280px and 768px widths.\n- Check Lighthouse for basic accessibility and layout shift issues.\n- Ensure Lucide icons render correctly and do not cause bundle errors.\n- Confirm Tailwind CDN loads once and classes apply as expected without FOUC.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "3",
        "title": "Zustand Unified Context Store Setup",
        "description": "Implement a unified Zustand store that holds PropertyContext, ProjectConfig, DesignHistory, and AssetLibrary slices.",
        "details": "Implementation details:\n- Install **Zustand 5.0.9**: `pnpm add zustand@5.0.9`.\n- In `/packages/core`, define TypeScript interfaces for high-level context domains (will be refined in Data Schema tasks):\n  - `PropertyContextSummary`, `ProjectConfigSummary`, `DesignRevisionSummary`, `AssetReferenceSummary`.\n- In `/apps/web/src/state/contextStore.ts`, create a root Zustand store using `create` and `immer` middleware (if desired) for immutable updates.\n- Design store structure to be module-friendly:\n```ts\nexport interface PropertyContextState { currentPropertyId?: string; properties: Record<string, PropertyContextSummary>; setCurrentProperty(id: string): void; upsertProperty(ctx: PropertyContextSummary): void; }\n\nexport interface ProjectConfigState { currentProjectId?: string; projects: Record<string, ProjectConfigSummary>; /* mutators */ }\n\nexport interface DesignHistoryState { revisionsByPropertyId: Record<string, DesignRevisionSummary[]>; addRevision(propId: string, rev: DesignRevisionSummary): void; }\n\nexport interface AssetLibraryState { assets: Record<string, AssetReferenceSummary>; addAsset(asset: AssetReferenceSummary): void; }\n\ntype UnifiedStore = PropertyContextState & ProjectConfigState & DesignHistoryState & AssetLibraryState;\n\nexport const useUnifiedStore = create<UnifiedStore>()(/* initial state + actions */);\n```\n- Expose convenient selectors/hooks for each module, e.g. `usePropertyContext()`, `useDesignHistory(propertyId)` to encourage separation of concerns.\n- Ensure store is serializable and stable across sessions (to be persisted later).\n",
        "testStrategy": "- Create a small test component that reads/writes to each slice and render it on a debug route.\n- Use React Testing Library with Jest/Vitest to validate store actions update state correctly.\n- Confirm there are no circular dependencies between store and domain models.\n- Check that React components subscribing to slices re-render only when relevant keys change (use Zustand selector/shallow comparison).",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "Domain Data Schema Definitions (Property, Measurement, Design, Asset)",
        "description": "Design and implement TypeScript domain models for PropertyContext, MeasurementSet, DesignRevision, and AssetReference as the canonical data schema.",
        "details": "Implementation details:\n- In `/packages/core/src/schema`, define types and helper factories for all core domain entities referenced in PRD-008.\n- Start with moderately normalized but pragmatic structures to avoid over-engineering while maintaining clarity.\n\nExample schemas:\n```ts\nexport type Unit = 'in' | 'ft' | 'cm' | 'm';\n\nexport interface MeasurementValue { value: number; unit: Unit; source: 'user' | 'doc' | 'web' | 'ai'; confidence: number; }\n\nexport interface MeasurementSet { id: string; propertyId: string; scope: 'room' | 'floor' | 'exterior' | 'global'; label: string; values: Record<string, MeasurementValue>; createdAt: string; updatedAt: string; }\n\nexport interface RoomContext { id: string; name: string; floorIndex: number; measurementsId?: string; tags: string[]; designIntent?: string; }\n\nexport interface PropertyContext { id: string; address: string; geo?: { lat: number; lng: number }; externalIds?: { zillowId?: string; redfinId?: string }; rooms: RoomContext[]; measurementSets: MeasurementSet[]; notes: string[]; }\n\nexport interface DesignRevision { id: string; propertyId: string; roomId?: string; createdAt: string; createdBy: 'user' | 'ai'; prompt: string; model: string; inputContextSnapshotId: string; outputAssetId?: string; metadata?: Record<string, unknown>; }\n\nexport interface AssetReference { id: string; type: 'image' | 'video' | 'model3d' | 'doc'; url: string; thumbnailUrl?: string; source: 'upload' | 'ai' | 'web'; mimeType?: string; width?: number; height?: number; metadata?: Record<string, unknown>; }\n```\n- Provide utility functions and Zod schemas (optional but recommended) for runtime validation:\n```ts\nimport { z } from 'zod';\nexport const MeasurementValueSchema = z.object({ value: z.number(), unit: z.enum(['in','ft','cm','m']), source: z.enum(['user','doc','web','ai']), confidence: z.number().min(0).max(1) });\n```\n- Ensure schemas are agnostic of persistence (DB) so they can be reused for client and future backend.\n",
        "testStrategy": "- Add unit tests validating Zod schemas accept valid examples and reject invalid data.\n- Write a few fixture generators (e.g. `createMockPropertyContext()`) and use them across tests.\n- Confirm schemas compose cleanly with Zustand store types (no circular type references).\n- Run TypeScript `tsc --noEmit` to confirm schema files are error free.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Environment & API Client Abstraction Layer",
        "description": "Create a centralized, secure abstraction for external API access (Gemini, Firecrawl, Zillow/Redfin, Google Maps, product APIs) with environment configuration.",
        "details": "Implementation details:\n- In `/packages/core/src/config/env.ts`, implement a small environment loader that reads from `import.meta.env` on the frontend and maps to strongly-typed config:\n```ts\nexport const env = {\n  GEMINI_API_KEY: import.meta.env.VITE_GEMINI_API_KEY ?? '',\n  FIRECRAWL_API_KEY: import.meta.env.VITE_FIRECRAWL_API_KEY ?? '',\n  // ...others\n};\n```\n- In `/packages/core/src/api`, define thin client modules per external service:\n  - `geminiClient.ts`\n  - `firecrawlClient.ts`\n  - `zillowClient.ts`\n  - `googleMapsClient.ts`\n- For security, plan that sensitive calls (e.g. API keys) will ultimately be proxied through a backend; for now, design clients to optionally accept an override `baseUrl` to swap from direct SaaS endpoint to backend proxy later.\n- Each client exposes minimal, use-case-based functions instead of raw HTTP wrappers, e.g.:\n```ts\nexport async function crawlPropertyAddress(address: string): Promise<CrawlResult> { /* call Firecrawl via fetch or axios */ }\n\nexport async function geocodeAddress(address: string): Promise<{ lat: number; lng: number } | null> { /* call Google Maps */ }\n```\n- Use `fetch` with AbortController for cancellation and simple retry for transient 5xx errors.\n- Centralize error handling and logging in a small `request.ts` helper.\n",
        "testStrategy": "- Implement mocked tests for each API client using MSW or similar to simulate HTTP responses.\n- Verify that clients throw typed errors on non-2xx responses.\n- Confirm environment variables are correctly read in dev and build modes.\n- Manually test one endpoint (e.g. Google Maps geocode) using a test API key and inspect network calls in DevTools.",
        "priority": "high",
        "dependencies": [
          "1",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Property Context Intelligence: Address-Based Web Crawling Integration",
        "description": "Integrate Firecrawl API to perform address-based web crawling and return structured raw context for properties.",
        "details": "Implementation details:\n- Using the `firecrawlClient` abstraction, add support for address-specific crawling:\n  - Build a search query combining address and key property platforms (Zillow, Redfin, realtor) in a Firecrawl job.\n  - Configure Firecrawl options to:\n    - Limit crawl depth to avoid over-fetching.\n    - Restrict domains (whitelist property listing sites).\n    - Enable PDF and image extraction.\n- Define `CrawlResult` type capturing:\n```ts\nexport interface CrawlResult { pages: { url: string; title?: string; html?: string; text?: string; pdfBytesBase64?: string; images?: string[]; }[]; }\n```\n- Implement a React hook `usePropertyCrawl(address)` that:\n  - Triggers Firecrawl request when user initiates context farming.\n  - Manages loading/error state.\n  - On success, stores raw crawl results in a temporary slice in Zustand (`propertyCrawlCache[address] = CrawlResult`).\n- Avoid tight coupling to extraction logic; extraction will be handled by AI in a separate task.\n- Add simple UI in a “Property Context” screen for triggering a crawl and viewing status.\n\nPseudo-code:\n```ts\nconst { mutate: runCrawl } = useMutation({\n  mutationFn: (address: string) => crawlPropertyAddress(address),\n  onSuccess: (result) => setPropertyCrawlCache(address, result),\n});\n```",
        "testStrategy": "- Use a known property address and mock Firecrawl responses to verify the hook and UI flow.\n- Ensure crawl job can be canceled if user navigates away.\n- Validate that repeated crawls for same address either reuse cache or explicitly refresh based on user choice.\n- Confirm that no parsing logic is mixed into this layer (raw results only).",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Source Document Upload & Ingestion Pipeline (PDFs, Images, Links)",
        "description": "Implement frontend upload and ingestion flows for user-provided PDFs, images, and links as part of property context farming.",
        "details": "Implementation details:\n- In the Property Context module UI, add an \"Add Sources\" section with:\n  - File upload for PDFs and images (`<input type=\"file\" multiple accept=\"application/pdf,image/*\" />`).\n  - Text field to add URLs for web pages or cloud-hosted documents.\n- For now, store raw file metadata in `AssetReference` entries with `source: 'upload'` and upload binaries to a temporary storage layer:\n  - If no backend exists, use browser memory/IndexedDB for prototype; design so that switching to S3 or GCS in backend is straightforward.\n- Integrate Firecrawl for URLs (when appropriate) and create `DocumentIngestionJob` type to track status:\n```ts\ntype DocSourceType = 'file-pdf' | 'file-image' | 'url';\ninterface DocumentIngestionJob { id: string; propertyId: string; sourceType: DocSourceType; assetId?: string; status: 'pending' | 'processing' | 'done' | 'error'; errorMessage?: string; }\n```\n- Add UI list of ingestion jobs with statuses and timestamps.\n- Ensure file size limits and basic client-side validation (e.g. max 50MB per file, supported MIME types).\n- Prepare metadata (`originalFilename`, `uploadedAt`, `propertyId`) for future AI parsing pipeline.\n",
        "testStrategy": "- Upload various test files (small/large PDFs, JPG/PNG images) and confirm they appear in the ingestion job list.\n- Attempt unsupported file types and verify clear validation errors.\n- Verify URL submission triggers a Firecrawl-based ingestion job.\n- Use unit tests for ingestion job management logic in Zustand store.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "AI Extraction & Structuring Pipeline for Property Context",
        "description": "Use Gemini models to extract and structure property details from crawled pages and uploaded documents into the PropertyContext schema.",
        "details": "Implementation details:\n- In `geminiClient`, add functions for text and document analysis using **gemini-2.5-flash** for fast extraction:\n```ts\nexport async function extractPropertyContextFromText(text: string): Promise<Partial<PropertyContext>> { /* call Gemini with structured prompt */ }\n```\n- Design prompts that instruct Gemini to output JSON strictly matching the `PropertyContext` and `MeasurementSet` schema fields, emphasizing:\n  - Address, room list, room types.\n  - Dimensions and measurement units.\n  - Not to hallucinate unknown values; mark missing fields as null.\n- For PDFs and images, pipe them through an OCR/parsing step:\n  - Use Firecrawl’s PDF parsing/OCR for text extraction when possible.\n  - For images (floorplans), send to Gemini vision endpoint (image understanding) and ask for detected rooms and approximate measurements when present.\n- Build an extraction orchestrator function:\n```ts\nexport async function buildPropertyContextFromSources(sources: { crawl?: CrawlResult; docs: DocumentIngestionJob[]; }): Promise<PropertyContextDraft> {\n  // 1. Aggregate text chunks\n  // 2. Call Gemini in batches\n  // 3. Merge partial contexts using deterministic rules (explicit doc > web > ai inference)\n}\n```\n- Store the resulting `PropertyContextDraft` in Zustand with a status flag (`draft`, `validated`, `error`).\n- Provide a review UI where the user can inspect and edit extracted rooms, measurements, and notes before saving as final context.\n",
        "testStrategy": "- Use synthetic sample data (mock Zillow text, sample floorplan PDF) and verify the pipeline creates a reasonable `PropertyContextDraft`.\n- Add tests to ensure merge logic prefers higher-confidence/explicit sources.\n- Validate JSON parsing from Gemini responses is resilient to minor format deviations (e.g., wrap parsing in try/catch and re-ask model if invalid).\n- Manually test with a real listing page and confirm that address, bedroom/bath counts, and obvious room names are captured.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Measurement Capture & Validation Workflow",
        "description": "Implement UX and logic for capturing, editing, and validating property measurements, combining user input with AI-extracted values.",
        "details": "Implementation details:\n- In the Property Context screen, add a \"Measurements\" tab that:\n  - Lists rooms for the selected property.\n  - Shows AI-extracted dimensions (length, width, height) with confidence indicators.\n  - Allows users to edit or add new values.\n- Model measurement conflicts and validation rules:\n  - Flag measurements with low confidence (<0.6) as \"Needs Review\".\n  - If multiple sources disagree beyond a tolerance (e.g. >5%), highlight the field and display source list.\n- Implement simple geometry-based validations where possible:\n  - Sum of room areas on a floor should not vastly exceed floor area if known.\n  - Basic min/max constraints for residential room sizes.\n- Provide a small helper summary for user: \"X of Y rooms validated\" and gate certain features (e.g., high-fidelity 3D generation) until minimum validation level is reached.\n- Persist validated measurements back into the `MeasurementSet` schema associated with the property.\n\nPseudo-code:\n```ts\nfunction validateMeasurementSet(set: MeasurementSet): ValidationResult {\n  // compute flags and messages\n}\n```",
        "testStrategy": "- Unit test validation logic with a range of measurement sets (consistent, inconsistent, missing values).\n- Manual QA: Edit measurements in the UI and ensure validation badges update in real time.\n- Verify measurements edited by the user override AI-extracted values in the stored schema.\n- Ensure no blocking errors occur when measurements are incomplete; only soft warnings unless explicitly required for a feature.",
        "priority": "medium",
        "dependencies": [
          "4",
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Gemini Chat & Vision Integration Layer",
        "description": "Implement a reusable Gemini chat and vision integration layer that supports text and image inputs with context injection from the unified store.",
        "details": "Implementation details:\n- Extend `geminiClient` with high-level functions:\n  - `runChatSession(messages, options)` for conversational text.\n  - `analyzeImageWithContext(imageUrl, context)` for design and schematic understanding.\n- Use **gemini-2.5-flash** for interactive chat and vision tasks; keep config for switching to other Gemini 3 models later.\n- Define a `ChatMessage` and `ChatSession` model to maintain history in Zustand `DesignHistory` slice.\n- Implement context injection:\n  - For each chat request, pull the active `PropertyContext`, `MeasurementSet`, and recent `DesignRevision` entries from store.\n  - Convert them to a concise system message: \"You are RemodelVision, an AI assisting with remodel planning for property at X. Here is current context: ...\" truncating to fit token limits.\n- Abstract model selection and temperature parameters in options:\n```ts\ninterface ChatOptions { model?: 'gemini-2.5-flash'; temperature?: number; maxOutputTokens?: number; }\n```\n- Ensure request/response handling is streaming-ready (even if initial UI uses full responses) to support faster perceived response later.\n",
        "testStrategy": "- Mock Gemini API in tests to validate request payload formatting and context injection.\n- Manual tests via a simple Chat UI: ask context-aware questions (e.g., \"How many bedrooms does my current property have?\") and verify answers reflect stored context.\n- Confirm that chat history persists within a session and is logged in `DesignHistory` with key fields.\n- Test error handling when API key is missing or invalid (clear user-facing message, no crashes).",
        "priority": "high",
        "dependencies": [
          "3",
          "4",
          "5",
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "11",
        "title": "Image Generation Pipeline (Nano Banana Pro / gemini-3-pro-image-preview)",
        "description": "Integrate Gemini’s photorealistic image generation capability to produce interior/exterior renders, schematic overlays, and before/after comparisons.",
        "details": "Implementation details:\n- In `geminiClient`, add a function using **gemini-3-pro-image-preview** (standing in for Nano Banana Pro) for image generation:\n```ts\nexport interface ImageGenRequest { prompt: string; negativePrompt?: string; width?: number; height?: number; seed?: number; inputImageUrl?: string; maskImageUrl?: string; }\n\nexport async function generateDesignImage(req: ImageGenRequest): Promise<AssetReference> { /* call Gemini image gen */ }\n```\n- Compose prompts from:\n  - User’s natural language intent.\n  - PropertyContext (room type, style preferences / \"Design DNA\" if known).\n  - MeasurementSet (for realism constraints where possible).\n- Implement output handling:\n  - Receive base64 or URL from Gemini, convert to a hosted URL (or blob URL for prototype) and register as an `AssetReference` with `source: 'ai'`.\n  - Link generated image to a new `DesignRevision` entry including prompt, model name, timestamp.\n- Support before/after comparisons:\n  - Allow user to select an existing room photo as `inputImageUrl` and request style changes.\n  - Store association between original and generated images for comparison overlays.\n- Implement rate limiting UI feedback (e.g., disable button, show spinner while generating) and basic quota awareness for the API key.\n",
        "testStrategy": "- Use a minimal prompt and verify that an image is successfully returned and displayed in the UI.\n- Validate that every generated image produces a corresponding `DesignRevision` entry with links to the AssetReference.\n- Manually test before/after functionality by selecting an input image and requesting a new style.\n- Include unit tests that ensure prompt composer includes key context fields when available.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "12",
        "title": "2D Result Comparison & Overlay View",
        "description": "Create UI to compare AI-generated images and schematics, including side-by-side and overlay modes for design iterations.",
        "details": "Implementation details:\n- In the Design Studio module, implement a comparison view component that:\n  - Accepts two or more `AssetReference` IDs (e.g., original vs AI-generated, different revisions).\n  - Provides modes: side-by-side, slider (before/after), and toggle.\n- For overlay slider view, use a simple CSS-based implementation:\n```tsx\n<div className=\"relative\">\n  <img src={beforeUrl} className=\"absolute inset-0\" />\n  <img src={afterUrl} style={{ clipPath: `inset(0 ${100 - sliderPercent}% 0 0)` }} />\n  {/* slider handle */}\n</div>\n```\n- Show associated metadata (prompt, date, room) under each image.\n- Integrate with `DesignHistory` so that user can pick which revisions to compare from a list or timeline.\n- Ensure images are lazily loaded and sized responsively to avoid layout thrash.\n",
        "testStrategy": "- Manually compare several generated images, verifying that slider moves smoothly and image alignment is correct.\n- Test selection of revisions from a history list populates the comparison view correctly.\n- Confirm that comparison view works for images of different sizes (fit to container with consistent aspect ratio handling).\n- Add simple component tests for the slider state and rendering of metadata.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4",
          "11"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "13",
        "title": "3D Engine Setup with Three.js and React-Three-Fiber",
        "description": "Configure the 3D rendering stack using Three.js 0.181.2, @react-three/fiber, and @react-three/drei for the dollhouse view foundation.",
        "details": "Implementation details:\n- Install 3D dependencies in web app:\n  - `pnpm add three@0.181.2 @react-three/fiber@9.4.2 @react-three/drei@10.7.7`.\n- Create a `<DollhouseCanvas>` component wrapping `Canvas` from `@react-three/fiber`:\n```tsx\nexport function DollhouseCanvas() {\n  return (\n    <Canvas camera={{ position: [0, 10, 10], fov: 45 }}>\n      <color attach=\"background\" args={[\"#0b1120\"]} />\n      <ambientLight intensity={0.3} />\n      <directionalLight position={[10, 20, 10]} intensity={0.8} />\n      <OrbitControls enablePan={true} enableZoom={true} maxPolarAngle={Math.PI / 2} />\n      {/* Scene content injected via children */}\n    </Canvas>\n  );\n}\n```\n- Use `drei` helpers (OrbitControls, Grid, Stats) for faster setup.\n- Ensure the canvas resizes with container, using CSS: `height: 100%; width: 100%;` and a flex parent.\n- Establish a simple scene graph structure where floors and rooms can later be added as separate components.\n",
        "testStrategy": "- Render the canvas in a dedicated \"3D Dollhouse\" route and confirm that camera controls and lighting work.\n- Check FPS and responsiveness on target hardware (modern laptops) with an empty scene.\n- Verify that React StrictMode does not cause unintended multiple mount side effects in the 3D components.\n- Confirm no console warnings from Three or React-Three-Fiber in dev mode.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Property Layout to 3D Dollhouse Mapping",
        "description": "Transform PropertyContext and MeasurementSet data into a 3D floor and room layout for the dollhouse view.",
        "details": "Implementation details:\n- Design mapping logic in `/packages/core/src/3d/layout.ts` that converts domain models into 3D primitives:\n```ts\nexport interface RoomMeshData { id: string; name: string; floorIndex: number; width: number; length: number; height: number; position: [number, number, number]; }\n\nexport function buildRoomMeshes(property: PropertyContext): RoomMeshData[] { /* compute from measurements */ }\n```\n- Use a simple coordinate system:\n  - Each room is approximated as a rectangular prism using primary length/width measurements; assume z-axis up.\n  - Floors stacked along Y/Z with a fixed vertical gap if height unknown.\n- Implement `<DollhouseScene>` that takes `RoomMeshData[]` and renders them as `mesh` with `BoxGeometry` and basic materials; differentiate floors with subtle color changes.\n- Enable room-level selection and hover via pointer events; update Zustand with `selectedRoomId`.\n- Plan for more complex layouts later (non-rectangular rooms) but keep first version rectangular for direct mapping and speed.\n",
        "testStrategy": "- Use mock PropertyContext with 1–2 floors and several rooms; verify visually that room sizes and positions roughly align with measurement data.\n- Click and hover on rooms, confirming selection state updates in Zustand and UI highlights.\n- Add unit tests for `buildRoomMeshes` for simple measurement inputs to ensure stable layout computations.\n- Confirm that lack of measurements results in safe defaults (e.g., 10x10 rooms) but with a visible warning in UI.",
        "priority": "medium",
        "dependencies": [
          "4",
          "9",
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "3D Viewport Capture for AI Processing",
        "description": "Implement functionality to capture 3D dollhouse viewport renders as images for use as input to Gemini image/vision models.",
        "details": "Implementation details:\n- In `DollhouseCanvas`, add a method to capture the current framebuffer:\n  - Use `gl.domElement.toDataURL(\"image/png\")` from Three.js renderer in a controlled way.\n  - Provide a React context or callback so parent components can trigger capture:\n```ts\nconst { gl, scene, camera } = useThree();\nfunction capture() {\n  gl.render(scene, camera);\n  const dataUrl = gl.domElement.toDataURL(\"image/png\");\n  onCapture?.(dataUrl);\n}\n```\n- Add a \"Capture View\" button in the UI near the 3D view that calls `capture()`.\n- Convert the captured data URL into an `AssetReference` (type `image`) and store it in AssetLibrary along with a link to the current `PropertyContext` and camera parameters.\n- Provide a quick action to send the captured image plus context to Gemini for analysis or variation generation.\n",
        "testStrategy": "- Manually capture the viewport and verify the resulting image matches the current camera orientation and scene.\n- Confirm that repeated captures generate distinct AssetReference entries and are associated with correct property.\n- Test sending a captured image through Gemini vision endpoint and verify response acknowledges scene characteristics (e.g., number of rooms visible).\n- Check performance impact: capturing should not freeze UI noticeably on modern hardware.",
        "priority": "medium",
        "dependencies": [
          "10",
          "11",
          "13",
          "14"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "16",
        "title": "Source Document Processing Workflow Orchestration",
        "description": "Create a cohesive workflow for processing uploaded documents and crawled pages into structured context, including progress tracking and retries.",
        "details": "Implementation details:\n- Implement a `ContextProcessingJob` model:\n```ts\ninterface ContextProcessingJob { id: string; propertyId: string; status: 'pending' | 'running' | 'succeeded' | 'failed'; steps: { id: string; name: string; status: 'pending' | 'running' | 'succeeded' | 'failed'; error?: string; }[]; createdAt: string; updatedAt: string; }\n```\n- Steps might include: \"Aggregate Sources\", \"Extract with Gemini\", \"Merge into Draft\", \"Validation\".\n- Create a small orchestrator service in `/packages/core/src/contextProcessing.ts` that:\n  - Accepts a propertyId, looks up associated crawl data and ingestion jobs.\n  - Runs `buildPropertyContextFromSources` (Task 8).\n  - Updates job step statuses in Zustand.\n- Expose controls in UI: \"Process Context\" button, job status view, and retry on failure.\n- Ensure operations are chunked to avoid blocking the main thread (use `setTimeout`/microtasks or Web Workers later if needed, but start simple).\n",
        "testStrategy": "- Simulate a context processing run with mocked sources and verify that each step’s status transitions correctly.\n- Test failure handling by forcing Gemini call to fail and check that job status reflects error with an actionable message.\n- Confirm that retrying re-runs from the beginning or from a safe checkpoint without duplicating context entries.\n- Ensure users can navigate away and back while a job runs, with state preserved in store.",
        "priority": "medium",
        "dependencies": [
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "17",
        "title": "Project Management Data Models & Store Integration",
        "description": "Define and integrate data models for project timelines, milestones, revision history, and status tracking per room/zone.",
        "details": "Implementation details:\n- Extend schemas in `/packages/core/src/schema`:\n```ts\nexport type ProjectStatus = 'planning' | 'in-progress' | 'on-hold' | 'completed';\n\nexport interface ProjectConfig { id: string; propertyId: string; name: string; description?: string; status: ProjectStatus; startDate?: string; targetEndDate?: string; budgetEstimate?: number; }\n\nexport interface Milestone { id: string; projectId: string; title: string; dueDate?: string; status: 'pending' | 'in-progress' | 'done'; relatedRoomIds?: string[]; }\n\nexport interface RoomStatus { projectId: string; roomId: string; status: 'not-started' | 'designing' | 'awaiting-approval' | 'construction' | 'done'; notes?: string; }\n```\n- Wire these into Zustand `ProjectConfigState`:\n  - Add maps for projects, milestones, and room statuses.\n  - Provide CRUD actions: `createProject`, `updateProject`, `createMilestone`, `setRoomStatus`, etc.\n- Ensure DesignRevision entries already reference projectId where applicable.\n",
        "testStrategy": "- Create unit tests verifying creation/update/deletion flows for projects and milestones in the store.\n- Check that linking between ProjectConfig, PropertyContext, and DesignRevision is consistent and type-safe.\n- Perform manual smoke tests: create a sample project, add milestones and room statuses via a simple debug UI.\n- Confirm that removing a project safely detaches or soft-deletes related milestones and statuses in store.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "18",
        "title": "Project Management Interface (Timeline & Room Status)",
        "description": "Build UI for contractor-grade project tracking including timeline views, room/zone status tracking, and basic revision access.",
        "details": "Implementation details:\n- In the \"Projects\" module UI:\n  - Provide a list of projects with status badges (planning, in-progress, etc.).\n  - Detail view shows description, associated property, and key metrics (e.g., number of rooms done).\n- Implement a simple timeline view (Gantt-lite):\n  - For each Milestone, display a bar spanning from now to due date or from start to due date if defined.\n  - Use plain div-based layout with Tailwind; no heavy chart library needed initially.\n- Create a \"Room Status\" table for the selected project:\n  - Rows: rooms; Columns: status, last updated, notes.\n  - Allow inline editing of room status and notes.\n- Link to DesignHistory: clicking a room opens a side panel listing design revisions associated with the project and room.\n",
        "testStrategy": "- Manually create a few projects and milestones and verify they render correctly in the timeline view.\n- Update room statuses and confirm changes persist in Zustand and reflect in the UI immediately.\n- Test responsiveness of timeline and tables at different viewport widths.\n- Validate that selecting a revision from the room panel navigates or scrolls to the design details view correctly.",
        "priority": "low",
        "dependencies": [
          "17",
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "19",
        "title": "General Contractor Intelligence Overlays (Annotations & Callouts)",
        "description": "Implement schematic annotation overlays and callout/labeling tools for trade-specific views (plumbing, electrical, etc.) on images and 3D views.",
        "details": "Implementation details:\n- Define annotation models in schema:\n```ts\nexport type TradeType = 'general' | 'plumbing' | 'electrical' | 'hvac' | 'structural';\n\nexport interface Annotation { id: string; assetId: string; propertyId: string; projectId?: string; trade: TradeType; type: 'point' | 'box' | 'polyline'; coordinates: any; text: string; createdAt: string; createdBy: string; }\n```\n- For 2D images (floorplans, renders), build an overlay component:\n  - Position annotations relative to image dimensions using normalized coordinates (0-1 range) for future-proofing.\n  - Allow creating/editing annotations (dragging pins, resizing boxes) and tagging with trade type.\n- For 3D view, support simple point annotations in scene space:\n  - Map 3D coordinates to screen positions using Three.js utilities for display of labels.\n- Create trade-specific filters (e.g., toggle to show only electrical annotations).\n- Store annotations in Zustand and link them to relevant assets and rooms.\n",
        "testStrategy": "- Manually create annotations on an image and verify they retain correct positions when image is resized or viewed on different screens.\n- Add several annotations with different trades and confirm filters work as expected.\n- Test 3D point annotations: label appears near object and remains consistent as camera moves.\n- Unit test coordinate normalization and denormalization logic.",
        "priority": "low",
        "dependencies": [
          "4",
          "11",
          "13",
          "14"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "20",
        "title": "Context-Preserving Navigation & Multi-Project Switching",
        "description": "Design and implement user interaction patterns for maintaining context across views and enabling quick switching among multiple properties/projects.",
        "details": "Implementation details:\n- In the app shell, add a global context bar showing current Property and Project with quick switchers:\n  - Property dropdown listing recent properties (from store) with search by address.\n  - Project dropdown filtered by selected property.\n- Ensure route-level components derive selected property/project from Zustand rather than URL alone, so switching via dropdown updates all relevant views (Property Context, 3D, Design Studio, Projects) consistently.\n- Implement context-preserving workflows:\n  - When user navigates from Design Studio to 3D view, retain selected property, project, and room.\n  - Use a shared `UIState` slice (in Zustand) to track selectedRoomId, selectedAssetId, and selectedTab.\n- Integrate design history navigation:\n  - A side panel listing design revisions with filters (by room, date, model) and a \"jump to\" action that updates active view while preserving overall context.\n",
        "testStrategy": "- Manual end-to-end flows: select a property, run context processing, open 3D view, generate images, then switch to another property and ensure state resets correctly without leaking old context.\n- Verify that browser refresh keeps current property/project selected if persisted (see Task 21).\n- Test rapid switching between properties/projects and confirm no React errors or stale data artifacts.\n- Add tests for UIState slice to ensure context transitions are predictable and avoid inconsistent combinations.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4",
          "10",
          "17"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "21",
        "title": "Client-Side Persistence & Session Restoration",
        "description": "Persist key user and property context data locally to ensure 100% context retention across sessions as per UX success metrics.",
        "details": "Implementation details:\n- Use Zustand middleware `persist` to store selected slices in `localStorage` (or IndexedDB for larger data) on the client:\n  - Persist: PropertyContext summaries, measurements, AssetReference metadata (not large binaries), ProjectConfig, UIState (current property/project/room), DesignHistory metadata.\n  - Do not persist: large raw crawl results and intermediate jobs (or limit size).\n- Configure versioning and migration for persisted store so schema changes can be handled safely:\n```ts\npersistConfig = { name: 'remodelvision-store', version: 1, migrate: (state, version) => { /* migration logic */ } };\n```\n- Add safeguards for storage quota issues (catch quota exceeded errors, show a warning to user, and provide a manual \"clear cache\" action).\n- Ensure sensitive tokens (API keys) are never stored in localStorage.\n",
        "testStrategy": "- Manually perform a workflow (create property, run context processing, generate design) then refresh the browser; verify that context, selections, and design history reappear.\n- Simulate a schema version change and test migration logic with mocked old state.\n- Confirm that no API keys or secrets are present in localStorage via DevTools inspection.\n- Test in multiple browsers (Chrome, Firefox, Safari) and private browsing where storage may be restricted; handle failures gracefully.",
        "priority": "high",
        "dependencies": [
          "3",
          "4",
          "8",
          "17",
          "20"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "22",
        "title": "Export & Sharing of Designs and Context",
        "description": "Implement export and sharing capabilities for design assets and project/context snapshots suitable for collaboration with contractors and stakeholders.",
        "details": "Implementation details:\n- Provide export options in Design Studio and Projects:\n  - Export selected images or sets of revisions as a ZIP or downloadable links (front-end bundling for prototype, backend later).\n  - Generate a summarized PDF-like document (HTML page printable to PDF) containing property summary, measurements, selected images, and annotations.\n- Implement shareable session snapshot model:\n```ts\ninterface ShareSnapshot { id: string; createdAt: string; propertyId: string; projectId?: string; includedRevisionIds: string[]; notes?: string; }\n```\n- For initial implementation, allow user to copy a JSON snapshot or local deep-link (non-public) that rehydrates context for the local user.\n- Ensure exported documents clearly indicate that AI outputs may require professional verification (disclaimer text).\n",
        "testStrategy": "- Manually export a sample project with a couple of revisions and verify that images and key context show up in the downloaded/printed document.\n- Test that deep-link or snapshot reopens the same property, project, and selection state when activated.\n- Confirm that exports do not include any secret keys or internal IDs that could be sensitive.\n- Validate basic print layout consistency across major browsers.",
        "priority": "low",
        "dependencies": [
          "4",
          "11",
          "12",
          "17",
          "19",
          "20",
          "21"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-09T05:42:13.024Z",
      "taskCount": 22,
      "completedCount": 0,
      "tags": [
        "master"
      ]
    }
  }
}